#### Find
1.  ReentrantLock supports a fairness parameter. What does it mean for a lock to be "fair"? Why might you choose to use a fair lock? Why might you not?
2.  What is ReentrantReadWriteLock? How does it differ from ReentrantLock? When might you use it?
3.  What is a "spurious wakeup"? When can one happen and why doesn't a well-written program care if one does?
4.  What is AtomicIntegerFieldUpdater? How does it differ from AtomicInteger? When might you use it?

#### Answers to Find
1.  From ReentrantLock JavaDoc:  
    > The constructor for this class accepts an optional fairness parameter. When set true, under contention, locks favor granting access to the longest-waiting thread. Otherwise this lock does not guarantee any particular access order. Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are slower; often much slower) than those using the default setting, but have smaller variances in times to obtain locks and guarantee lack of starvation. Note however, that fairness of locks does not guarantee fairness of thread scheduling. Thus, one of many threads using a fair lock may obtain it multiple times in succession while other active threads are not progressing and not currently holding the lock.
2.  ReentrantReadWriteLock is an implementation of the ReadWriteLock interface. One might use it for a concurrent data structure that gets read a lot more than it gets written to.
The JavaDoc has this to say about the interface:  
    > A ReadWriteLock maintains a pair of associated locks, one for read-only operations and one for writing. The read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The write lock is exclusive.
3.  A well-written program doesn't care because a condition being awaited in such a program is awaited inside a loop.  
From Wikipedia (highlight from me):  
    > Spurious wakeup describes a complication in the use of condition variables as provided by certain multithreading APIs such as POSIX Threads and the Windows API.  
    > Even after a condition variable appears to have been signaled from a waiting thread's point of view, the condition that was awaited may still be false. One of the reasons for this is a spurious wakeup; that is, a thread might be awoken from its waiting state even though no thread signaled the condition variable. For correctness it is necessary, then, to verify that the condition is indeed true after the thread has finished waiting. Because spurious wakeup can happen repeatedly, this is achieved by ***waiting inside a loop*** that terminates when the condition is true.  
    > According to David R. Butenhof's Programming with POSIX Threads ISBN 0-201-63392-2: "This means that when you wait on a condition variable, the wait may (occasionally) return when no thread specifically broadcast or signaled that condition variable. Spurious wakeups may sound strange, but on some multiprocessor systems, making condition wakeup completely predictable might substantially slow all condition variable operations. The race conditions that cause spurious wakeups should be considered rare."
4.  The volatile keyword guarantees that reads and writes to the applied variable will not be reordered, thereby ensuring we don't run into memory consistency error (such as in Puzzle class p. 13). The keyword, however, does not give us atomic operations. AtomicIntegerFieldUpdater allows us, through reflection, to target the volatile variables of a class and imbue them with atomicity.  
Selected interesting passages from the JavaDoc on the java.util.concurrency.atomic package:  
> A small toolkit of classes that support lock-free thread-safe programming on single variables. In essence, the classes in this package extend the notion of volatile values, fields, and array elements to those that also provide an atomic conditional update operation of the form:  
>  _boolean compareAndSet(expectedValue, updateValue);_  
This method (which varies in argument types across different classes) atomically sets a variable to the updateValue if it currently holds the expectedValue, reporting true on success. The classes in this package also contain methods to get and unconditionally set values.  
> The specifications of these methods enable implementations to employ efficient machine-level atomic instructions that are available on contemporary processors. However on some platforms, support may entail some form of internal locking.  
> In addition to classes representing single values, this package contains Updater classes that can be used to obtain compareAndSet operations on any selected volatile field of any selected class. AtomicReferenceFieldUpdater, AtomicIntegerFieldUpdater, and AtomicLongFieldUpdater are reflection-based utilities that provide access to the associated field types. These are mainly of use in atomic data structures in which several volatile fields of the same node (for example, the links of a tree node) are independently subject to atomic updates. ***These classes enable greater flexibility in how and when to use atomic updates, at the expense of more awkward reflection-based setup, less convenient usage, and weaker guarantees.***

#### Do
1.  What would happen if the loop within the "dining philosophers" implementation that uses condition variables was replaced with a simple if statement? What failure modes might you see? What would happen if the call to signal() was replaced by signalAll()? What problems (if any) would this cause?
2.  Just as intrinsic locks are more limited than ReentrantLock, they also support a more limited type of condition variable. Rewrite the dining philosophers to use an intrinsic lock plus the wait() and notify() or notifyAll() methods. Why is it less efficient than using ReentrantLock?
3.  Write a version of ConcurrentSortedList that uses a single lock instead of hand-over-hand locking. Benchmark it against the other version. Does hand-over-hand locking provide any performance advantage? When might it be a good choice? When might it not?

#### Answers to Do
1.  If the loop was replaced with a simple if statement then when only one of the left or right philosopher would wake up the waiting thread with a signal() call the resumed thread would continue to eat, which is obviously wrong, because the philosopher can't eat unless both the left and right philosophers aren't eating.  
We also wouldn't handle spurious wakeups properly, because when the waiting thread would be spuriously woken up it wouldn't recheck the condition to deal with that.  
Nothing will happen if the call to signal() is replaced by signalAll(). Let's say we replace left.condition.signal() with left.condition.signalAll(). There is only one thread awaiting this condition, namely the left Philosopher (remember, Philosopher extends Thread). Since only one thread is awaiting this condition signaling only one awaiting thread or all awaiting threads comes down to the same thing.
2.  See code under folder DiningPhilosophersIntrinsicNotify. The concept of a Lock and a Condition in ReentrantLock has kind of been squished into one in Object. Object has an intrinsic lock and methods wait(), notify(), notifyAll(), that map to methods await(), signal(), and signalAll(), in Condition. Using ReentrantLock's newCondition() method we can create multiple conditions for a given lock. That is not possible for Object since the condition concept is baked into Object. In our example that means we can't selectively signal/notify the left and right philosopher, we have to either signal everybody or signal a single thread, maybe a thread who doesn't benefit from us stopping eating (such as a philosopher sitting opposite us, i.e. not right next to us).
3.  ***TODO code solution***. If we want to do a lot of write operations at once using hand-over-hand locking might not be such a good idea due to overhead of performing a lot of locking.

#### Notes
*   When using ReentrantLock's lock method, the thread will block if another thread already owns the lock. The tryLock method however doesn't block, instead it returns false.  
Similarly, a thread trying to acquire a monitor lock that is already owned by another tread will block.
